---
title: 2025-5-21-为什么官方LLVM会报错的思考
---
目前在试图看出来为什么新官方llvm编译half.ll会报错，目前认为不是指令的问题，应该是ll文件的问题。这是2025年LLVM中关于fnmadd的相关ll，它专门建立了一个文件叫做fnmadd.ll
```
; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed 's/iXLen/i32/g' %s | llc -mtriple=riscv32 -mattr=+v,+zvfh \
; RUN:   -verify-machineinstrs -target-abi=ilp32d | FileCheck %s
; RUN: sed 's/iXLen/i64/g' %s | llc -mtriple=riscv64 -mattr=+v,+zvfh \
; RUN:   -verify-machineinstrs -target-abi=lp64d | FileCheck %s

declare <vscale x 1 x half> @llvm.riscv.vfnmadd.nxv1f16.nxv1f16(
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  iXLen, iXLen, iXLen);

define <vscale x 1 x half>  @intrinsic_vfnmadd_vv_nxv1f16_nxv1f16_nxv1f16(<vscale x 1 x half> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, iXLen %3) nounwind {
; CHECK-LABEL: intrinsic_vfnmadd_vv_nxv1f16_nxv1f16_nxv1f16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsrmi a1, 0
; CHECK-NEXT:    vsetvli zero, a0, e16, mf4, tu, ma
; CHECK-NEXT:    vfnmadd.vv v8, v9, v10
; CHECK-NEXT:    fsrm a1
; CHECK-NEXT:    ret
entry:
  %a = call <vscale x 1 x half> @llvm.riscv.vfnmadd.nxv1f16.nxv1f16(
    <vscale x 1 x half> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    iXLen 0, iXLen %3, iXLen 0)

  ret <vscale x 1 x half> %a
}

declare <vscale x 1 x half> @llvm.riscv.vfnmadd.mask.nxv1f16.nxv1f16(
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  <vscale x 1 x half>,
  <vscale x 1 x i1>,
  iXLen, iXLen, iXLen);

define <vscale x 1 x half>  @intrinsic_vfnmadd_mask_vv_nxv1f16_nxv1f16_nxv1f16(<vscale x 1 x half> %0, <vscale x 1 x half> %1, <vscale x 1 x half> %2, <vscale x 1 x i1> %3, iXLen %4) nounwind {
; CHECK-LABEL: intrinsic_vfnmadd_mask_vv_nxv1f16_nxv1f16_nxv1f16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsrmi a1, 0
; CHECK-NEXT:    vsetvli zero, a0, e16, mf4, tu, mu
; CHECK-NEXT:    vfnmadd.vv v8, v9, v10, v0.t
; CHECK-NEXT:    fsrm a1
; CHECK-NEXT:    ret
entry:
  %a = call <vscale x 1 x half> @llvm.riscv.vfnmadd.mask.nxv1f16.nxv1f16(
    <vscale x 1 x half> %0,
    <vscale x 1 x half> %1,
    <vscale x 1 x half> %2,
    <vscale x 1 x i1> %3,
    iXLen 0, iXLen %4, iXLen 0);

  ret <vscale x 1 x half> %a
}
```
但是这是老版本的half.ll
```
; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define dso_local half @fnmadd_f(half noundef %a, half noundef %b, half noundef %c) local_unnamed_addr  {
; VENTUS-LABEL: fnmadd_f:
; VENTUS:       # %bb.0: # %entry
; VENTUS-NEXT:    lui t0, %hi(.LCPI26_0)
; VENTUS-NEXT:    lw t0, %lo(.LCPI26_0)(t0)
; VENTUS-NEXT:    vadd.vx v0, v1, zero
; VENTUS-NEXT:    vmv.v.x v1, t0
; VENTUS-NEXT:    vfmsub.vv v0, v1, v2
; VENTUS-NEXT:    ret
entry:
  %fneg = fmul half %b, 0xBFF3333340000000
  %sub = fsub half %fneg, %c
  ret half %sub
}
```
导致出错的正好是0xBFF333334000000，相关数字在新LLVM中完全消失了